# Dependency Injection

## Factory

OOP에서, 팩토리는 다른 객체들을 만들어주는 객체다. 팩토리 객체 내의 메소드가 호출되었을 때, 다양한 프로토타입 또는 클래스의 객체들을 반환한다.

## Singleton Pattern

싱글턴 패턴을 따르는 클래스는 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이다. 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디장니 유형을 싱글턴 패턴이라고 한다.

## Spring AOP(Aspect Oriented Programming)

Spring AOP(Aspect Oriented Programming)는 관점 지향 프로그래밍을 지원하는 Spring 프레임워크의 일부이다. AOP는 애플리케이션의 핵심 비즈니스 로직에서 공통적으로 사용되는 기능(로깅, 트랜잭션 관리, 보안 등)을 핵심 로직으로부터 분리하여 재사용 가능하게 만드는 프로그래밍 패러다임이다. 이를 통해 코드의 모듈성을 향상시키고, 유지보수를 용이하게 한다.

Spring AOP는 "관점(Aspect)"를 사용하여 공통 기능을 정의한다. 관점은 애플리케이션의 여러 위치에서 적용될 수 있는 일련의 작업을 의미한다. 예를 들어, 메소드 호출 전후에 로그를 기록하는 관점을 정의할 수 있다. 이러한 관점은 특정 "조인 포인트(Join Point)"에 삽입되며, 조인 포인트는 애플리케이션 실행 중에 관점이 적용될 수 있는 특정 지점(예: 메소드 실행, 필드 접근 등)을 나타낸다.

### Spring AOP의 주요 개념

- Aspect: 공통 기능을 모듈화한 것. 예를 들어, 트랜잭션 관리나 로깅 등을 관점으로 정의할 수 있다.
- Join Point: 관점이 적용될 수 있는 애플리케이션의 지점. Spring AOP에서는 메소드 실행이 주요 조인 포인트이다.
- Advice: 관점이 특정 조인 포인트에서 취해야 할 액션이다. 예를 들어, 메소드 호출 전에 로그를 기록하는 것이 하나의 어드바이스가 될 수 있다.
- Pointcut: 어드바이스를 적용할 조인 포인트를 지정하는 표현식. 특정 메소드나 클래스의 메소드에 어드바이스를 적용하고자 할 때 사용한다.
- Target: 어드바이스가 적용되는 객체이다.
- Proxy: Spring AOP는 런타임에 프록시를 사용하여 관점을 적용한다. 대상 객체에 대한 호출은 먼저 프록시를 통과하게 되며, 프록시는 필요에 따라 어드바이스를 실행한 후 실제 객체로 요청을 전달한다.

## IoC(Inversion of Control) & Dependency Injection

### IoC

제어의 반전은 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 의미한다.

전통적인 프로그래밍에서의 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용한다.

하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출한다.

#### 마틴 파울러가 말하는 IoC - "Don't call us, we'll call you"

IoC는 프레임워크를 확장할 때 자주 마주치는 일반적인 현상이다. 실제로 이는 프레임워크의 정의적 특성으로 종종 간주된다.

커맨드라인 형태

```ruby
  #ruby
  puts 'What is your name?'
  name = gets
  process_name(name)
  puts 'What is your quest?'
  quest = gets
  process_quest(quest)
```

윈도우를 통해서

```
  require 'tk'
  root = TkRoot.new()
  name_label = TkLabel.new() {text "What is Your Name?"}
  name_label.pack
  name = TkEntry.new(root).pack
  name.bind("FocusOut") {process_name(name)}
  quest_label = TkLabel.new() {text "What is Your Quest?"}
  quest_label.pack
  quest = TkEntry.new(root).pack
  quest.bind("FocusOut") {process_quest(quest)}
  Tk.mainloop()
```

위와 아래 예시의 차이는? - 제어 흐름에 큰 차이를 보인다.(특히 process_name 및 process_quest 메소드가 호출되는 시점의 제어권에서 있어서)

커맨드 라인 형태에서는 이러한 메소드들이 언제 호출될지를 내가 제어할 수 있지만, 윈도우 예제에서는 그렇지 않다. 대신, 제어권을 윈도잉 시스템에 넘겨준다.(Tk.mainloop 명령을 사용하여). 그러면 시스템이 폼을 생성할 때 만든 바인딩을 기반으로 내 메소드를 언제 호출할지 결정한다. 프레임워크가 나를 호출하는 것이지, 나로서는 프레임 워크를 호출하지 않는 것이다. 이 현상이 바로 제어의 역전(Inversion of Control)이다.

프레임워크의 중요한 특성 중 하나는 사용자가 프레임워크를 맞춤 설정하기 위해 정의한 메소드들이 종종 사용자의 애플리케이션 코드가 아닌 프레임워크 자체 내에서 호출된다는 것이다. 프레임워크는 주로 애플리케이션 활동을 조정하고 순서를 지정하는 메인프로그램 역할을 한다. 이러한 제어의 역전은 프레임워크에 확장 가능한 골격으로서 기능할 수 있는 힘을 준다.

제어의 역전은 프레임워크를 라이브러리와 다르게 만드는 핵심 부분이다. 라이브러리는 본질적으로 호출할 수 있는 함수들의 집합이며, 요즘은 주로 클래스로 구성된다. 각 호출은 일부 작업을 수행하고 제어권을 클라이언트에게 반환한다.

프레임워크는 내장된 더 많은 행동과 함께 어떤 추상적 디자인을 포함한다. 이를 사용하기 위해서는 서브클래싱을 하거나 자신의 클래스를 플러그인하는 방식으로 프레임워크의 여러 부분에서 자신의 행동을 삽입해야 한다. 그러면 프레임워크의 코드가 이러한 지점에서 나의 코드를 호출한다.

### IoC의 목적

- 작업을 구현하는 방식과 작업 수행 자체를 분리한다.
- 모듈 제작 시 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있다.
- 다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 된다.
- 모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않는다.

### Dependency Injection

IoC가 너무 일반적인 용어이기 때문에, 사람들이 혼란스러워하므로 마틴파울러가 Dependency Injection이라는 이름으로 정함.

## Spring Bean

Spring이 관리하는 객체를 Bean이라고 하며, Spring Bean이라고 콕 짚어서 말한다.

## BeanFactory

Spring 빈 컨테이너에 접근하기 위한 루트 인터페이스이다.

BeanFactory는 각각 문자열 이름으로 고유하게 식별되는 여러 빈 정의를 보유하는 객체에 의해 구현된다. ListableBeanFactory 및 ConfigurableBeanFactory와 같은 추가 인터페이스가 있다.

빈 정의에 따라 BeanFactory가 포함한 객체의 독립 인스턴스(프로토타입 디자인 패턴) 또는 단일 공유 인스턴스(인스턴스가 팩토리 범위의 싱글톤인 싱글톤 디자인 패턴의 대안)를 반환할 것이다. 어떤 유형의 인스턴스가 반환될지는 빈 팩토리 구성에 따라 다르다.

이 접근방식의 요점은 BeanFactory가 애플리케이션 컴포넌트의 중앙 등록소이며 애플리케이션 컴포넌트의 구성을 중앙 집중화한다는 것이다. 이는 개별 객체가 프로퍼티 파일을 읽을 필요가 없다는 장점이 있다.

일반적으로 BeanFactory 조회와 같은 어떤 형태의 "pull"구성을 사용하는 것보다 setter나 생성자를 통해 애플리케이션 객체를 구성하는 데 의존성 주입("push")에 의존하는 것이 더 낫다. Spring의 의존성 주입 기능은 이 BeanFactory 인터페이스와 그 하위 인터페이스를 사용하여 구현된다.
