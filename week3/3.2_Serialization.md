# 직렬화 Serialization

- 직렬화는 컴퓨터 과학의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일거나 다른 컴퓨터 환경에 저장하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정 (파일이나 메모리 버퍼에서, 또는 네트워크 연결 링크 간 전송 시)
- 오브젝트를 직렬화 하는 과정은 오브젝트를 마샬링한다고도 함
- 반대로, 일련의 바이트로부터 데이터 구조를 추출하는 일은 역직렬화라고 한다.
- 객체를 그 자체로 DB에 저장하거나, 네트워크로 전송하는 건 불가능
- 객체를 복구할 수 있도록 데이터화 하는게 필요함
- 바이너리라면 Byte Stream, 텍스트라면 기계가 파싱할 수 있고 사람도 읽을 수 있는 형태 사용
- XML, JSON, YAML 같은 형식이 인기

# 마샬링(Marshalling)

- 마셜링이란 한 객체의 메모리에서 표현방식을 저장 또는 전송에 적합한 다른 데이터 형식을 변환하는 과정
- 또한 이는 데이터를 컴퓨터프로그램의 서로 다른 부분 간에 혹은 한 프로그램에서 다른 프로그램으로 이동해야 할 때도 사용
- 마셜링은 직렬화와 유사하며 직렬화된 오브젝트로 멀린 오브젝트와 통신하기 위해 사용된다.
- 마셜링의 반대개념으로 언마셜링, 디마셜링이 있으며 역직렬화와 유사하다.

마셜링의 용도

- 마셜링은 프로세스간 또는 스레드 간 데이터 전송에 필요한 원격 프로시저 호출(Remote Procedure Call, RPC) 매커니즘의 구현에 사용된다.

## 직렬화와 마샬링

직렬화와 마샬링은 데이터를 다른 형태로 변환하는 과정으로 의미가 거의 같지만, Java에선 마샬링 동일하게 간주하지 않음

- 직렬화 : 데이터 구조나 객체 상태를 저장하거나 전송 가능한 형태로 변환하는 과정

  - 주로 객체의 상태를 파일에 저장하거나, 네트워크를 통해 다른 시스템으로 객체를 전송할 때 사용됨
  - 예를 들어, Java에서 객체를 직렬화하여 바이트 스트림으로 변환하고, 이를 파일에 저장하거나 네트워크를 통해 다른 시스템에 전송할 수 있다.

  ```JAVA
  // Java에서의 객체 직렬화 예시
  Person person = new Person("홍길동", 30);
  FileOutputStream fileOut = new FileOutputStream("person.ser");
  ObjectOutputStream out = new ObjectOutputStream(fileOut);
  out.writeObject(person);
  out.close();
  fileOut.close();
  ```

  - 위 예시에서, 'Person' 객체는 직렬화되어 바이트 스트림으로 변환된 후, 파일에 저장된다. 이 과정을 통해 객체의 상태가 보존되어 나중에 역직렬화를 통해 원본 객체로 복원할 수 있다.

- 마셜링 : 객체나 데이터 구조를 원격 통신을 위해 전송 가능한 형태로 변환하는 과정

  - 마셜링은 주로 원격 프로시저 호출(RPC)이나 웹 서비스 통신에서 객체를 전송하기 위해 사용된다.
  - 예를 들어, SOAP 웹 서비스 통신에서는 객체를 XML 형태로 마셜링하여 원격 시스템에 전송한다.

- 오브젝트를 "마셜링 한다"는 것은 그것의 상태와 코드베이스를 기록하는 것을 의미
- 이것은 마셜링된 오브젝트가 언마셜링될 때, 오브젝트의 클래스 정의를 아마도 자동적으로 로딩함으로써 원본 오브젝트의 사본을 얻는 방식으로 기록되는 방식이다.
- 직렬화 될 수 있거나, 원격의 어떤 오브젝트라도 마셜링할 수 있다.
- 직렬화는 마셜링처럼 코드베이스를 기록하지 않는다.
- 마셜링이 직렬화와 다른 점은 원격 오브젝트를 특별하게 다룬다는 점
- 여기서 말하는 코드베이스의 의미는 소스 코드를 일컫는 더 일반적인 의미의 코드베이스가 아니라, 자바에 국한되어 오브젝트 코드가 로드되는 URL의 목록을 참조하기 위한 것이라는 의미로 사용된다.
- 오브젝트를 "직렬화 한다"는 것은 오브젝트의 상태를 오브젝트 사본으로 다시 변환할 수 있는 바이트 스트림으로 변환하는 것을 의미한다.

직렬화는 실제 객체 또는 데이터를 remote pc에 보내는 것이라면, 마샬링은 직렬화를 포함하며 원격 객체를 조종할 수 있는 리모컨을 얻는 것과 같은 기능 또한 포함한다.

- 직렬화(Serialization) : 역직렬화(Deserialization)를 통해 객체 또는 데이터의 복사
- 마샬링(Marshalling) : 직렬화와 같거나, 원격 객체로 복원할 수 있음. 원격 객체의 경우, 메서드 RPC(또는 RMI)가 됨

### Java RMI(Remote Method Interface)

RMI 시스템은 네트워크를 통해 객체의 메소드 호출을 마셜링하고 언마셜링하는 과정을 캡슐화하여, 개발자가 마치 로컬 객체를 다루듯이 원격객체를 쉽게 조작할 수 있도록 한다.

- 서버는 원격 객체를 생성하고 RMI 레지스트리에 등록
- 클라이언트는 이 원격 객체를 RMI 레지스트리를 통해 찾고, 메소드를 호출하여 원격 객체와 상호작용 한다.

1. 원격 인터페이스를 정의
2. 이를 구현하는 클래스를 만들기
3. 클라이언트가 서버에 있는 원격 객체의 메소드를 호출할 수 있도록 한다.

## JSON(JavaScript Object Notation) - 자바 스크립트 오브젝트 표기법

- JSON : 문자열 형태로 존재하는 속성-값 쌍, 배열(Array도 제한된 key-value + length 관리에 불과하다.), 또는 다른 직렬화 가능한 값들로 구성된 데이터 객체를 저장하고 전송하는 오픈 스탠다드 파일 포맷 및 데이터 교환 포맷이다.
- 사람이 읽기 쉽고, 기계도 해석 또는 생성하기 쉽게 만들어졌다.
- 이는 전자 데이터 교환에서 다양하게 사용되는 데이터 포맷으로, 서버와 웹 애플리케이션 간의 통신에 흔히 사용된다.
- JSON은 언어 독립적인 데이터 포맷이며 JavaScript에서 파생되었지만, 현대의 많은 프로그래밍 언어들은 JSON 포맷 데이터를 생성하고 파싱하기 위한 코드를 포함하고 있다.
- Java는 Map이 Json과 유사하지만, 스키마 관리 및 타입 안전성을 위해 DTO를 활용한다.

  - 생성: DTO (Java 세계) → 변환기 → JSON 문자열
  - 해석: JSON 문자열 → 변환기 → DTO (Java 세계)

- Java에선 [Jackson](https://github.com/FasterXML/jackson)이란 도구가 유명하고, Spring Boot에서 Web 의존성을 추가하면 바로 사용할 수 있다(즉, 우리는 딱히 아무 것도 안 해도 된다).
- 변환할 때 getter 사용. @JsonProperty로 속성 이름(key) 지정 가능. 다른 객체(DTO)를 포함하고 있어도 됨.

### JSON 스키마로서의 DTO (class)

DTO는 여러 곳에서 사용될 수 있고, 그 의미는 계속 확대됨. 예를 들어 Tier, 즉 Remote 통신이 아닌 상황인 Layer 사이나 내부 객체를 감춘 공개 인터페이스를 만들 때도 DTO를 활용. “데이터 전송”이기만 하면 딱히 틀리지 않다.

우리가 여기서 쓰는 건 JSON 스키마로서의 DTO. 이게 DTO의 전부라고 생각하지 말고, DTO를 쓰는 다양한 상황을 상상해 보자. 이는 “DTO 변환을 어디에서 해야 하나요?” 같은 질문과 연결된다

### 스키마란?

- 데이터의 구조, 형식, 그리고 데이터 간의 관계를 정의하는 일종의 틀이나 규칙을 가리킨다.
- JSON 스키마는 JSON 데이터의 구조를 미리 정의해 두는 것으로, 해당 스키마에 따라 JSON 데이터가 올바른 형식과 값을 가지고 있는지 검증할 수 있다.
- DTO(Data Transfer Object)를 JSON 스키마로서 사용한다는 것은, DTO가 JSON 데이터 교환 시 데이터의 구조와 형식을 정의하는 역할을 한다는 의미
- DTO는 특정 데이터 모델이나, 애플리케이션 간에 데이터를 주고받을 때 그 데이터의 구조를 나타내는 JSON 스키마로 사용된다.
